# Redis 相关知识总结

## 1. Redis是什么？
Redis 是一个基于内存、支持多种数据结构的 NoSQL 键值数据库。它利用内存存储与丰富的数据结构，主要应用于缓存、会话存储、实时排行榜等高性能场景，并能通过持久化机制保障数据可靠性。

## 2. Redis底层的数据结构？
Redis 常见五种数据类型：String（字符串）、Hash（哈希）、List（列表）、Set（集合）、Zset（有序集合）。后续版本新增 BitMap、HyperLogLog、GEO、Stream。

### 应用场景：
- **String**：缓存对象、常规计数、分布式锁、共享 session
- **List**：消息队列（需自行实现全局唯一 ID，不支持消费组）
- **Hash**：缓存对象、购物车
- **Set**：聚合计算（并集、交集、差集），如点赞、共同关注、抽奖
- **Zset**：排序场景，如排行榜、电话姓名排序
- **BitMap（2.2+）**：二值状态统计，如签到、用户登陆状态
- **HyperLogLog（2.8+）**：海量数据基数统计，如网页 UV 计数
- **GEO（3.2+）**：存储地理位置信息，如滴滴叫车
- **Stream（5.0+）**：消息队列，支持全局唯一消息 ID 和消费组

## 3. ZSet底层实现？
- 元素个数 < 128 且每个值 < 64 字节时使用压缩列表（Redis 7.0 后由 listpack 替代）
- 不满足上述条件时使用跳表

## 4. 跳表实现原理？
跳表是多层有序链表，通过"层级索引"实现快速查找（复杂度 O(logN)）。节点结构包含：
- 元素值（sds ele）
- 权重值（double score）
- 后向指针（指向前驱节点）
- 层级数组（每层包含前向指针和跨度）

**层高设置**：创建节点时生成 [0,1] 随机数，若小于 0.25（25%概率）则层高 +1，重复直到随机数 > 0.25 或达到最大层高 64。

## 5. Redis为什么用跳表不用B+树？
- **内存访问**：跳表指针跳转符合 CPU 缓存局部性，B+树节点结构复杂且缓存不友好
- **实现复杂度**：跳表代码简洁（约200行），无复杂平衡操作；B+树需节点分裂/合并，代码量庞大
- **写入性能**：跳表插入/删除仅调整局部指针；B+树可能触发递归节点分裂，成本高
- **内存占用**：跳表结构紧凑无内部碎片；B+树节点预分配可能浪费内存

## 6. 压缩列表实现？
压缩列表是为节约内存设计的顺序型数据结构，包含：
- zlbytes：总字节数
- zltail：尾部节点偏移量
- zllen：节点数量
- zlend：结束标记（0xFF）

**节点结构**：
- prevlen：前驱节点长度（支持反向遍历）
- encoding：当前数据类型和长度
- data：实际数据

**缺点**：可能发生连锁更新（插入/删除导致后续节点需重新分配空间）。Redis 3.2 引入 quicklist、5.0 引入 listpack 以优化。

## 7. listpack介绍？
为解决压缩列表连锁更新问题，Redis 5.0 引入 listpack：
- 节点不再记录前驱节点长度，避免连锁更新
- 节点结构：encoding（数据类型和长度）、data（实际数据）、len（总长度）
- 紧凑内存布局，支持不同编码节省内存

## 8. 哈希表扩容机制？
采用渐进式 rehash：
1. 分配大小为当前哈希表 2 倍的新空间（哈希表2）
2. 在 rehash 期间，每次增删改查操作时，将哈希表1中对应索引位置的键值迁移到哈希表2
3. 迁移完成后释放哈希表1，将哈希表2设置为新表

**读请求处理**：先查哈希表1，未找到再查哈希表2

## 9. String的存储结构？
使用 SDS（简单动态字符串）而非 C 字符串，结构包含：
- len：字符串长度（O(1) 获取）
- alloc：已分配空间长度（避免缓冲区溢出）
- flags：SDS 类型标识（sdshdr5/8/16/32/64）
- buf[]：字符数组（可存储文本或二进制数据）

**优势**：
- O(1) 复杂度获取长度
- 二进制安全（可存储包含 \0 的数据）
- 自动扩容防溢出

## 10. Redis为什么快？
- 内存操作：数据存于内存，读写效率高
- 高效数据结构：如哈希表、跳表等优化查询
- 单线程模型：避免多线程竞争与切换开销，无死锁问题
- I/O 多路复用：通过 select/epoll 机制单线程处理多路 I/O 流

## 11. Redis的多线程应用？
- **后台线程（BIO）**：
  - 2.6+：关闭文件、AOF 刷盘
  - 4.0+：lazyfree 线程异步释放内存（如 unlink key）
- **I/O 多线程（6.0+）**：
  - 默认多线程处理网络 I/O（读写分离）
  - 命令执行仍为单线程
  - 配置 io-threads N 启用 N-1 个 I/O 线程

## 12. I/O多路复用实现？
基于 Reactor 模式，文件事件处理器通过 I/O 多路复用模块监控多个文件描述符（fd）。当 accept、read、write 等事件触发时，回调绑定的事件处理器执行命令。

**工作流程**：
1. 将客户端 socket 注册到监听队列
2. I/O 多路复用程序封装命令为事件并绑定 fd
3. 文件事件处理器单线程处理就绪事件

## 13. Redis网络模型？
- 6.0 前：单 Reactor 单线程，适用于 CPU 非密集型场景
- 6.0 后：多线程处理网络 I/O，提升网络并行度；命令执行仍为单线程

## 14. Redis如何保证原子性？
- **单命令原子性**：单线程执行，天然原子性
- **多命令原子性**：
  - Lua 脚本：整个脚本作为一个整体执行，不被中断（如分布式锁解锁操作）
  - 事务：MULTI/EXEC 组合保证多个操作原子性（但错误时不回滚）

## 15. Redis持久化方式及优缺点？
- **AOF 日志**：
  - 优点：数据安全性高（支持每秒/每次同步），可修复（redis-check-aof）
  - 缺点：文件体积大，写性能受影响（尤其 always 策略），恢复慢
- **RDB 快照**：
  - 优点：文件小，恢复快，fork 子进程不影响主线程
  - 缺点：可能丢失两次快照间数据，故障恢复可能不一致

**写回策略**：
- Always：每次写操作同步刷盘（安全，性能低）
- Everysec：每秒刷盘（平衡性能与安全）
- No：由操作系统决定刷盘时机（性能高，可能丢失数据）

## 16. 过期删除与内存淘汰策略区别？
- **过期删除**：清理已过期的键值对，策略为惰性删除 + 定期删除
- **内存淘汰**：内存不足时淘汰数据，通过 maxmemory-policy 配置策略

## 17. 内存淘汰策略？
- **不淘汰**：noeviction（默认，返回错误）
- **淘汰过期键**：
  - volatile-random：随机淘汰
  - volatile-ttl：优先淘汰更早过期键
  - volatile-lru：淘汰最近最少使用
  - volatile-lfu：淘汰使用频率最低
- **全局淘汰**：
  - allkeys-random：随机淘汰
  - allkeys-lru：淘汰最近最少使用
  - allkeys-lfu：淘汰使用频率最低

## 18. 过期删除策略？
- **惰性删除**：访问键时检查过期并删除
- **定期删除**：每秒随机抽查 20 个键，若过期键占比 >25% 则继续抽查，否则等待下一轮

## 19. 过期键是否立即删除？
否，采用惰性删除 + 定期删除组合。立即删除会占用大量 CPU 时间，影响性能。

## 20. 主从同步机制？
- **全量同步**：
  1. 从节点发送 SYNC 命令
  2. 主节点生成 RDB 快照并传输
  3. 从节点加载 RDB，主节点同步期间写命令存入 backlog buffer
  4. 传输 backlog 中的写命令
- **增量同步**：
  - 基于 repl_backlog_buffer（环形缓冲区）和复制偏移量
  - 从节点发送 PSYNC 命令，主节点判断偏移量差异在缓冲区内则发送增量数据

## 21. 主从/集群能否保证数据一致性？
属于 AP 模型（可用性、分区容错性），网络分区时可能数据不一致，最终一致性。

## 22. 哨兵机制原理？
实现主从故障转移：
1. 监控：哨兵节点定期检测主从节点状态
2. 选主：主节点客观下线后，选举 Sentinel Leader 并选择新主节点
3. 通知：将新主节点信息同步给从节点和客户端

**选主算法**：
- 过滤故障节点
- 按 slave-priority > 复制偏移量 > runid 最小 选择新主

## 23. 集群模式优缺点？
- **优点**：高可用性、高性能（分片）、扩展性好
- **缺点**：部署维护复杂、集群同步延迟、数据分片限制功能

**数据分布**：采用哈希槽（16384 个），通过 CRC16 取模映射数据到节点。

## 24. Redis使用场景？
- 缓存：提升访问速度，减轻数据库负载
- 排行榜：有序集合实现实时排序
- 分布式锁：SET NX PX 命令实现
- 计数器：INCR/DECR 原子操作
- 消息队列：List/Pub-Sub/Stream 实现

## 25. Redis为什么比MySQL快？
- 内存存储：无磁盘 I/O 瓶颈
- 简单数据结构：哈希表 O(1) 查询 vs B+Tree O(log n)
- 单线程模型：无锁竞争与切换开销

## 26. 本地缓存 vs Redis缓存？
- **本地缓存**：
  - 优点：访问速度快、低延迟、减轻网络压力
  - 缺点：可扩展性有限、数据不一致
- **Redis缓存**：
  - 优点：可扩展性强、数据一致性高、易于维护
  - 缺点：网络开销大、访问速度相对慢

## 27. 高并发场景性能？
- 缓存命中：单节点 Redis 可支撑 10W QPS
- 缓存未命中：单节点 MySQL 约 5000 QPS

## 28. 分布式锁实现原理？
- **加锁**：`SET lock_key unique_value NX PX 10000`
- **解锁**：Lua 脚本验证 unique_value 后删除
```lua
if redis.call("get", KEYS[1]) == ARGV[1] then
  return redis.call("del", KEYS[1])
else
  return 0
end
```

## 29. 大Key问题与解决？
**定义**：String 类型 value > 1MB 或集合元素 > 1 万

**问题**：
- 内存压力、性能下降
- 阻塞操作、网络拥塞
- 数据倾斜、主从同步延迟

**解决方案**：
- 拆分大 Key（如 HASH 分片）
- 异步删除（unlink）
- 监控内存水位
- 定期清理过期数据

## 30. 热Key问题与解决？
**定义**：单个 Key 请求集中（如 QPS 占比高）

**解决方案**：
- 复制热 Key 到多个分片（集群模式）
- 读写分离架构增加从节点

## 31. 缓存一致性方案？
- **读策略**：旁路缓存（cache miss 时从 DB 加载）
- **写策略**：更新 DB 后删除缓存
- **优化方案**：
  - 删除重试（消息队列）
  - 订阅 binlog（Canal + 消息队列）

## 32. 缓存雪崩/击穿/穿透？
- **缓存雪崩**：大量缓存同时失效
  - 解决：均匀设置过期时间、互斥锁、后台更新缓存
- **缓存击穿**：热点数据过期
  - 解决：互斥锁、永不过期 + 异步更新
- **缓存穿透**：查询不存在的数据
  - 解决：非法请求限制、缓存空值、布隆过滤器

## 33. 布隆过滤器原理？
- 位图数组 + N 个哈希函数
- 写入时计算哈希值置位 1，查询时判断位是否全为 1
- 特点：存在误判（可能假阳性），但不会漏判

## 34. 秒杀场景设计？
**数据库层面**：
- `SELECT ... FOR UPDATE` 加排他锁
- `UPDATE ... SET stock=stock-1 WHERE stock>0` 库存限制

**分布式方案**：
- 分布式锁：同一商品串行化处理
- 分段缓存：库存分多段 key，并发处理不同段
- Redis原子操作：DECR 预减库存 + 异步队列写库

## 35. Redis常用命令？
**Key操作**：
- `KEYS pattern`：模式匹配查找 key
- `DEL key`：删除指定 key
- `EXPIRE key seconds`：设置过期时间
- `TTL key`：查看剩余过期时间

**String操作**：
- `SET key value`：设置值
- `GET key`：获取值
- `INCR key`：数值+1
- `SETEX key seconds value`：设值并过期

**Hash操作**：
- `HSET key field value`：设置字段值
- `HGET key field`：获取字段值
- `HGETALL key`：获取所有字段值

**事务操作**：
- `MULTI`：开始事务
- `EXEC`：执行事务
- `DISCARD`：取消事务
