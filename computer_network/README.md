# 计算机网络面试核心知识点大全

## 一、 网络模型基础

### 1.1 OSI 七层模型 vs. TCP/IP 四层模型

**通俗理解**：把网络通信想象成发送一封跨国信件。
*   **OSI 模型**：理论上的完美流程，分了7个步骤，每个步骤专人负责，但太复杂，现实中不直接用。
*   **TCP/IP 模型**：实际使用的简化流程，分了4个步骤，高效实用。

| OSI 七层模型 | TCP/IP 四层模型 | 核心功能 | 通俗比喻 | 常见协议 |
| :--- | :--- | :--- | :--- | :--- |
| 应用层 | 应用层 | **为用户提供应用服务** | **写信的内容**：“亲爱的妈妈，我很好...” | HTTP, HTTPS, FTP, DNS, SMTP |
| 表示层 | ^ | **数据格式转换**（加密、压缩） | **翻译官**：把中文翻译成英文，或者把内容加密 | - |
| 会话层 | ^ | **建立、管理和终止会话** | **对话管理**：决定是打电话还是写信，什么时候开始/结束 | - |
| 传输层 | 传输层 | **为应用层提供端到端的可靠/不可靠传输** | **邮政的打包和运输服务**：确认包裹是否收到，没收到就再发一个 | **TCP, UDP** |
| 网络层 | 网络层 | **寻址和路由**（选择最佳路径） | **地址和邮路**：根据收件地址（IP），选择飞机、轮船等运输路线 | **IP, ICMP, Router** |
| 数据链路层 | 网络接口层 | **在相邻节点间无差错地传输数据帧** | **本地邮局和邮差**：负责你家到本地邮局这段路的准确投递 | Ethernet, MAC, Switch |
| 物理层 | ^ | **在物理媒介上传输原始比特流** | **公路和卡车**：负责把包裹实际运走，关心的是电压、光信号等 | Fiber, Cable, Radio |

**面试关键**：记住 TCP/IP 四层模型和每一层的核心协议（特别是 **TCP/IP** 在哪层）。

---

## 二、 应用层 (Application Layer)

### 2.1 HTTP

#### 2.1.1 HTTP 报文结构

*   **请求报文**
    ```http
    GET /index.html HTTP/1.1          // 请求行：方法 + URL + 协议版本
    Host: www.baidu.com               // 请求头：包含请求的元信息
    User-Agent: Mozilla/5.0...
    Accept: text/html
    (空行)                            // 分隔头部和体
    (请求体)                          // 例如 POST 方法提交的表单数据
    ```
*   **响应报文**
    ```http
    HTTP/1.1 200 OK                   // 状态行：协议版本 + 状态码 + 状态信息
    Content-Type: text/html           // 响应头：包含响应的元信息
    Content-Length: 1024
    (空行)                            // 分隔头部和体
    <html>...                         // 响应体：服务器返回的实际内容
    ```

#### 2.1.2 HTTP 状态码

| 类别 | 描述 | 常见状态码 | 通俗理解 |
| :--- | :--- | :--- | :--- |
| 1xx | **信息性** | 100 Continue | “我收到了请求头，你继续发身体吧。” |
| 2xx | **成功** | **200 OK** | “请求成功，这是你要的东西。” |
| 3xx | **重定向** | **301 Moved Permanently** | “你要的东西已**永久**搬新家了，以后请直接去新家。” |
| ^ | ^ | **302 Found** | “你要的东西**临时**在另一个地方，这次去那里拿。” |
| 4xx | **客户端错误** | **400 Bad Request** | “你的请求语法有问题，我看不懂。” |
| ^ | ^ | **401 Unauthorized** | “你需要登录（认证）才能访问。” |
| ^ | ^ | **403 Forbidden** | “你登录了，但权限不够（禁止访问）。” |
| ^ | ^ | **404 Not Found** | “你要的东西不存在。” |
| 5xx | **服务器错误** | **500 Internal Server Error** | “服务器内部出错了，我也不知道为啥。” |
| ^ | ^ | **502 Bad Gateway** | “我（网关/代理）后面的服务器给我了个无效响应。” |
| ^ | ^ | **503 Service Unavailable** | “服务器当前太忙，无法处理你的请求。” |
| ^ | ^ | **504 Gateway Timeout** | “我（网关/代理）后面的服务器响应太慢了，我超时了。” |

#### 2.1.3 HTTP 请求方法

*   **GET**： **获取**资源。像在浏览器地址栏输入网址。
*   **POST**： **提交/创建**资源。像填写表单并提交。
*   **PUT**： **更新**整个资源。
*   **DELETE**： **删除**资源。
*   **HEAD**： 只获取资源的**头部信息**，不要内容。用于检查资源是否存在、是否被修改过。

#### 2.1.4 GET vs POST (核心区别)

| 方面 | GET | POST |
| :--- | :--- | :--- |
| **语义** | **获取**数据（安全、幂等） | **提交**数据（不安全、不幂等） |
| **数据位置** | URL 的 `?` 后面（Query String） | 请求体（Body）中 |
| **数据长度** | 受 URL 长度限制（浏览器不同） | 理论上无限制 |
| **安全性** | 参数暴露在URL，可被缓存、历史记录 | 相对安全，但仍是明文 |
| **缓存** | 可被缓存 | 默认不可缓存 |
| **书签** | 可收藏为书签 | 不可收藏 |

> **幂等性**：同样的请求执行一次或多次，产生的**效果**是一样的。GET（查）、PUT（改）、DELETE（删）是幂等的，POST（增）不是。

#### 2.1.5 HTTP 长连接 (Keep-Alive)

*   **短连接**：每次请求-响应都要经历一次 TCP 的“三次握手”和“四次挥手”。**好比打电话，说一件事就挂断，再说再打。**
*   **长连接**：完成一次请求-响应后，TCP 连接不立即关闭，可以被多个 HTTP 请求复用。
    **好比打电话，接通后可以连续聊好几件事，最后再挂。**

**优点**：减少了 TCP 连接建立和关闭的开销，提升了性能。

### 2.2 HTTPS

#### 2.2.1 HTTP 为什么不安全？

HTTP 是**明文传输**，就像寄明信片，路上谁都能看到内容。存在三大风险：
1.  **窃听**：内容被偷看。
2.  **篡改**：内容被修改。
3.  **冒充**：冒充成目标网站。

#### 2.2.2 HTTPS 如何解决？

HTTPS = HTTP + SSL/TLS，相当于给 HTTP 套了一层**加密外壳**。
1.  **混合加密**：保证内容不被窃听。
    *   **非对称加密**：在握手初期，用于安全地交换**对称加密**的密钥。**好比用一把公开的锁（公钥）把一个小保险箱（对称密钥）锁上寄给对方，只有对方的私钥能打开。**
    *   **对称加密**：在握手完成后，用于加密实际传输的数据。**效率高，好比双方都有了同一把钥匙，用来加密和解密信件。**
2.  **数字证书**：保证对方身份真实，防止冒充。
    *   由权威的 **CA（证书颁发机构）** 颁发，证明“这个公钥就是百度官网的”。
    *   浏览器会验证证书的真伪和有效性。
3.  **摘要算法**：保证数据完整性，防止篡改。
    *   对数据计算一个唯一的“指纹”（摘要），如果数据被篡改，指纹就对不上。

#### 2.2.3 HTTPS  TLS 握手过程 (RSA 版本)

**比喻**：A 和 B 想建立一个安全的通信渠道。
1.  **Client Hello**：A 对 B 说：“你好，我想建立安全连接。我支持的密码套件有...，这是我的随机数1。”
2.  **Server Hello**：B 回应：“好的，我们用这套密码吧。这是我的**证书**（里面有我的公钥），这是我的随机数2。”
3.  **客户端验证**：A 检查 B 的证书是否可信（就像检查身份证是不是公安局发的）。
4.  **Pre-master Key**：A 生成一个**预主密钥**，用 B 的**公钥**加密后，发给 B。**（只有 B 的私钥能解密）**
5.  **生成会话密钥**：A 和 B 都使用**随机数1、随机数2、预主密钥**，通过相同的算法，生成相同的**会话密钥**（用于对称加密）。
6.  **客户端就绪**：A 说：“以后我们就用这个会话密钥加密了。”
7.  **服务端就绪**：B 说：“好的，我也准备好了，开始加密通信吧！”

> **注意**：现在更主流的是 **ECDHE 密钥交换**，它能在第一次通信时就完成密钥交换，实现“**向前保密**”（即使服务器私钥泄露，过去的通信也无法被解密）。

### 2.3 HTTP/1.1 vs HTTP/2

| 特性 | HTTP/1.1 | HTTP/2 |
| :--- | :--- | :--- |
| **核心模型** | 基于文本，按顺序处理请求 | 基于二进制分帧，多路复用 |
| **连接复用** | 一个连接只能处理一个请求-响应（队头阻塞） | **一个连接可并行处理多个请求-响应** |
| **头部压缩** | 重复发送大量相同的头部 | 使用 **HPACK** 算法压缩，大大减小开销 |
| **服务器推送** | 不支持 | 服务器可以主动向客户端推送资源 |

**队头阻塞通俗解释**：HTTP/1.1 中，一个 TCP 连接就像一个单车道，前面的车（请求）慢了，后面的车都得等着。HTTP/2 把它变成了多车道，所有车可以并行跑。

### 2.4 DNS (域名系统)

#### 2.4.1 DNS 解析过程

**比喻**：你想找“老王家的地址”，但你不知道。
1.  查**本地通讯录**（浏览器缓存、系统 hosts 文件） -> 没找到。
2.  问**本地居委会**（本地 DNS 服务器） -> 没找到。
3.  居委会问**全球地址管理中心**（根域名服务器）：“.com 区域谁管？” 根告诉你：“去问 .com 管理局。”
4.  居委会问 **.com 管理局**（顶级域服务器）：“baidu.com 谁管？” .com 告诉你：“去问百度公司的地址管理处。”
5.  居委会问**百度地址管理处**（权威域名服务器）：“www.baidu.com 的地址是啥？” 管理处告诉你：“是 X.X.X.X”。
6.  居委会把地址 X.X.X.X 告诉你，并把地址记在自己的小本本上（缓存），方便下次有人问。

#### 2.4.2 DNS 使用 UDP 还是 TCP？

*   **主要使用 UDP**：因为查询请求和响应通常很小，UDP 无连接、开销低、速度快。**好比问路，一句话的事，用不着建立正式连接。**
*   **使用 TCP 的情况**：
    1.  当响应报文太大（超过 512 字节），UDP 装不下时，会使用 TCP。
    2.  在主从域名服务器之间进行**区域传输**（同步数据）时，使用 TCP，因为数据量大，需要可靠性。

### 2.5 Cookie, Session, Token

#### 2.5.1 为什么需要它们？

因为 **HTTP 是无状态的**。服务器记不住你是谁，每次请求都像初次见面。需要用一种机制来“保持状态”（如登录状态）。

#### 2.5.2 三者区别

| | **Cookie** | **Session** | **Token (如 JWT)** |
| :--- | :--- | :--- | :--- |
| **存储位置** | **客户端** | **服务端** | **客户端** |
| **工作原理** | 服务器通过 `Set-Cookie` 头下发一小段文本，客户端后续请求自动带上。 | 服务器为每个用户创建唯一的 Session ID，通常通过 Cookie 发给客户端。服务器保存 Session 数据。 | 服务器生成一个包含用户信息的 Token（经过签名），客户端保存，每次请求在 Header 中带上。 |
| **安全性** | 较低，可能被 XSS 窃取。可通过 `HttpOnly` 防 JS 读取。 | 较高，敏感数据在服务器。 | 依赖加密和签名，需要防范 Token 泄露。 |
| **扩展性** | 好 | 集群环境下需要共享 Session 机制（如 Redis） | **非常好**，无状态，天然支持分布式。 |
| **生命周期** | 可设置过期时间 | 一般浏览器关闭即失效，或服务器设定超时 | 由 Token 自身过期时间决定 |

#### 2.5.3 JWT (JSON Web Token)

*   **结构**：`Header.Payload.Signature`
    *   `Header`：声明类型和签名算法。
    *   `Payload`：存放实际需要传递的数据（如用户ID），**但它是明文的，不要放密码等敏感信息**。
    *   `Signature`：对前两部分的签名，用于验证 Token 是否被篡改。
*   **优点**：无状态、适合跨域、性能好（无需查数据库）。
*   **缺点**：**一旦签发，在到期前无法废止**。解决方法是使用**黑名单**或设置较短的过期时间并用 Refresh Token 来续期。

---

## 三、 传输层 (Transport Layer)

### 3.1 TCP vs UDP

| 特性 | TCP (传输控制协议) | UDP (用户数据报协议) |
| :--- | :--- | :--- |
| **连接性** | **面向连接**（如打电话） | **无连接**（如发短信） |
| **可靠性** | **可靠**，保证数据不丢、不重、按序 | **不可靠**，尽最大努力交付 |
| **传输形式** | **字节流**，无边界 | **数据报文**，有边界 |
| **首部开销** | 大 (20-60 字节) | 小 (8 字节) |
| **速度** | 慢 | 快 |
| **应用场景** | 网页(HTTP)、邮件(SMTP)、文件传输(FTP) | 视频流、语音通话、DNS查询、直播 |

### 3.2 TCP 三次握手

**比喻**：A 和 B 打电话确认通话。
1.  **A -> B**：`SYN=1, seq=x` （“喂，听得到吗？我这边准备好了。”） - **A 进入 SYN_SENT**
2.  **B -> A**：`SYN=1, ACK=1, ack=x+1, seq=y` （“听得到。你也能听到我吗？我也准备好了。”） - **B 进入 SYN_RCVD**
3.  **A -> B**：`ACK=1, ack=y+1` （“好的，我也能听到你，那我们开始聊吧！”） - **A、B 都进入 ESTABLISHED**

**为什么是三次？**
*   **主要目的**：**防止已失效的连接请求报文突然又传到了服务器**，从而产生错误。
    *   **例子**：A 发了个连接请求，但堵在路上了。A 超时重发，建立了连接并断开。此时那个旧的请求终于到了 B，如果是两次握手，B 就会傻傻地一直等着 A 发数据，浪费资源。三次握手下，A 不会理会 B 对这个旧请求的确认，连接就不会建立。
*   次要原因：三次握手才能**同步双方的初始序列号**，这是可靠传输的基础。

### 3.3 TCP 四次挥手

**比喻**：A 和 B 打完电话，要挂断。
1.  **A -> B**：`FIN=1, seq=u` （“我说完了，要挂电话了。”） - **A 进入 FIN_WAIT_1**
2.  **B -> A**：`ACK=1, ack=u+1` （“哦，我知道你说完了。”） - **B 进入 CLOSE_WAIT**，**A 进入 FIN_WAIT_2**
    *   *此时 B 可能还有数据要传给 A。*
3.  **B -> A**：`FIN=1, ACK=1, seq=w, ack=u+1` （“我也说完了，可以挂了。”） - **B 进入 LAST_ACK**
4.  **A -> B**：`ACK=1, ack=w+1` （“好的，再见。”） - **A 进入 TIME_WAIT**，等待 **2MSL** 后关闭。**B 收到 ACK 后关闭。**

**为什么是四次？**
因为 TCP 是**全双工**的，关闭需要两个方向独立进行。第二步和第三步之间，是 B 在把自己的事情收尾。

**为什么 TIME_WAIT 状态需要等待 2MSL？**
1.  **保证最后一个 ACK 能到达 B**：如果 B 没收到 ACK，会超时重传 FIN，A 在 2MSL 时间内还能收到并重发 ACK。
2.  **让本次连接的所有报文都在网络中消失**，避免影响后续的新连接。

### 3.4 TCP 可靠传输机制

1.  **序列号和确认应答 (ACK)**：每个包都有编号，接收方收到后要回复 ACK：“我收到 X 号包了，下一个我想要 Y 号。”
2.  **超时重传**：发送方在一定时间内没收到 ACK，就认为包丢了，会重新发送。
3.  **流量控制**：通过 **滑动窗口** 机制，接收方告诉发送方：“我还能收多少数据”，防止发送太快把接收方缓冲区撑爆。
4.  **拥塞控制**：防止发送太快把**网络**撑爆。包含几个算法：
    *   **慢启动**：一开始小心翼翼地指数增长发送速度。
    *   **拥塞避免**：达到阈值后，转为线性增长。
    *   **快重传/快恢复**：收到 3 个重复 ACK 时，立即重传丢失的包，并进入恢复阶段，而不是傻傻地等超时。

### 3.5 TCP 粘包/拆包

**原因**：TCP 是字节流，没有消息边界。应用程序一次读到的数据可能包含多个应用消息，或者不完整的一个消息。

**解决方案**：
1.  **定长消息**：每个消息都一样长，不够补零。
2.  **分隔符**：在每个消息末尾加一个特殊字符（如 `\n`），像 HTTP 那样。
3.  **消息头+消息体**：在消息头中声明消息体的长度。**这是最常用的方法。**

---

## 四、 网络场景与故障排查

### 4.1 在浏览器输入 URL 后发生了什么？

1.  **URL 解析**：分析协议、域名、路径。
2.  **DNS 查询**：将域名解析成 IP 地址。
3.  **建立 TCP 连接**：与服务器进行三次握手。
4.  **TLS 握手**：如果是 HTTPS，进行加密握手。
5.  **发送 HTTP 请求**：浏览器发送请求报文。
6.  **服务器处理并返回响应**：服务器返回 HTML、CSS、JS 等资源。
7.  **浏览器解析渲染**：浏览器解析资源，渲染页面。
8.  **TCP 连接关闭**：页面加载完成后，可能进行四次挥手关闭连接（或保持长连接）。

### 4.2 网页访问慢，如何排查？

1.  **检查客户端**：其他网站也慢吗？-> 是，则是本地网络问题。-> 否，进入下一步。
2.  **DNS 解析**：`nslookup 域名` 看解析是否慢或出错。
3.  **网络连通性**：`ping 目标IP` 看延迟和丢包。`traceroute` 看在哪一跳慢了。
4.  **服务端状态**：检查服务器 CPU、内存、负载。查看服务端日志。
5.  **应用层分析**：浏览器 F12 打开开发者工具，看 Network 面板哪个资源加载慢，状态码是什么。
    *   如果是 **TTFB (Time to First Byte)** 慢，可能是服务器处理慢或网络延迟高。
    *   如果是 **Content Download** 慢，可能是网络带宽不足或资源太大。

### 4.3 服务器上有大量 TIME_WAIT / CLOSE_WAIT 怎么办？

*   **大量 TIME_WAIT**：通常出现在**主动关闭连接**的一方（如反向代理服务器、频繁调用后端 API 的客户端）。
    *   **原因**：短连接太多，频繁创建和关闭连接。
    *   **解决**：
        1.  开启 HTTP **长连接**。
        2.  调整内核参数 `net.ipv4.tcp_tw_reuse`（允许重用 TIME_WAIT 的连接）。
*   **大量 CLOSE_WAIT**：通常出现在**被动关闭连接**的一方。
    *   **原因**：对方发来了 FIN，但我方程序**没有正确地调用 `close()`** 来关闭 socket。**这通常是 BUG！**
    *   **解决**：检查应用程序代码，确保资源被正确释放。

---

## 五、 网络攻击与安全

### 5.1 DDoS 攻击

*   **是什么**：攻击者控制成千上万的“肉鸡”（僵尸网络），同时向目标服务器发送海量无效请求，耗尽其资源（带宽、CPU、连接数），导致正常用户无法访问。
*   **防范**：使用高防 IP、流量清洗服务、CDN 来分散和过滤恶意流量。

### 5.2 XSS (跨站脚本攻击)

*   **是什么**：攻击者在网页中插入恶意脚本，当用户浏览时，脚本会在用户浏览器中执行，盗取 Cookie 或进行其他操作。
*   **分类**：
    *   **存储型**：恶意脚本被存到数据库（如论坛发帖），影响所有访问者。
    *   **反射型**：恶意脚本在 URL 参数中，诱使用户点击。
    *   **DOM 型**：在前端 JS 中直接操作 DOM 时发生。
*   **防范**：对用户输入进行**转义**和**过滤**，设置 Cookie 为 `HttpOnly`。

### 5.3 CSRF (跨站请求伪造)

*   **是什么**：攻击者诱导用户在自己已登录的网站上，去点击一个恶意链接或页面，从而在用户不知情下，以用户的身份执行恶意操作（如转账、改密码）。
*   **防范**：
    1.  **使用 CSRF Token**：服务器生成一个随机 Token 藏在表单里，提交时验证。
    2.  **校验 `Referer` 头**：检查请求来源是否合法。
    3.  **SameSite Cookie**：设置 Cookie 的 `SameSite` 属性，禁止跨站发送。

### 5.4 SQL 注入

*   **是什么**：攻击者通过在用户输入中插入 SQL 代码，欺骗服务器执行恶意的 SQL 命令。
*   **例子**：登录时，用户输入用户名 `' OR '1'='1' --`，可能导致 SQL 变成 `SELECT * FROM users WHERE username = '' OR '1'='1' --' AND password=...`，从而绕过登录。
*   **防范**：**永远不要拼接 SQL 字符串！** 使用**预编译语句 (Prepared Statements)** 或 **ORM 框架**。

## 六、 网络层与数据链路层深度解析

### 6.1 IP 协议与 IP 地址

#### 6.1.1 IP 协议的作用

IP（Internet Protocol）是网络层的核心协议，负责**主机的逻辑寻址**和**数据包的路由转发**。它提供的是**无连接**、**不可靠**的服务。

*   **无连接**：发送数据前不需要建立连接，直接发送。
*   **不可靠**：它不保证数据包能到达目的地，也不保证数据包的顺序。可靠性由上层协议（如TCP）来保障。

**通俗比喻**：IP协议就像邮政系统中的**标准信封和邮政编码**。它规定了地址怎么写，包裹怎么打包，但不关心包裹是否丢失，也不负责确认对方是否收到。

#### 6.1.2 IPv4 地址与子网掩码

*   **IPv4 地址**：32位二进制数，通常用点分十进制表示（如 `192.168.1.1`）。它由**网络号**和**主机号**两部分组成。
*   **子网掩码**：用来区分一个IP地址中的网络部分和主机部分。例如，`255.255.255.0`（/24）表示前24位是网络号，后8位是主机号。

**CIDR（无类别域间路由）**：一种更灵活的IP地址分配方法，使用 `IP地址/前缀长度` 的表示法（如 `192.168.1.0/24`）。

#### 6.1.3 公有IP vs 私有IP

*   **公有IP**：在全球互联网中唯一的IP地址，需要向ISP申请。
*   **私有IP**：在局域网内部使用的IP地址，不能在公网上直接路由。RFC 1918规定了私有地址段：
    *   `10.0.0.0/8`
    *   `172.16.0.0/12`
    *   `192.168.0.0/16`

**NAT（网络地址转换）**：为了解决IPv4地址枯竭问题，NAT技术允许一个局域网内的多个私有IP共享一个公有IP访问互联网。路由器负责将内部私有IP和端口映射到公有IP和端口。

### 6.2 ICMP 协议

ICMP（Internet Control Message Protocol）是IP协议的辅助协议，用于在主机和路由器之间传递**控制信息**，如网络通不通、主机是否可达、路由是否可用等。

*   **常见应用**：`ping` 命令（使用ICMP回显请求和回显应答报文）和 `traceroute` 命令。
*   **面试常问**：**为什么ping不通但服务可能能访问？**
    *   可能目标主机的防火墙禁用了ICMP回显请求（即禁ping），但开放了服务的端口（如80端口）。

### 6.3 ARP 协议

ARP（Address Resolution Protocol）负责将**IP地址**解析为**MAC地址**（物理地址）。

**工作过程**（以主机A ping 主机B为例）：
1.  A查看自己的**ARP缓存表**，看是否有B的IP对应的MAC地址。
2.  如果没有，A会在局域网内**广播**一个ARP请求包：“谁的IP是B的IP？请告诉A你的MAC地址。”
3.  局域网内所有主机都会收到，但只有B会**单播**回应一个ARP应答包：“我是B，我的MAC地址是XX:XX:XX:XX。”
4.  A收到应答后，将B的IP-MAC映射存入ARP缓存，然后开始发送数据。

**ARP欺骗/攻击**：攻击者伪造ARP应答，声称自己的MAC地址对应某个IP，从而劫持网络流量。

### 6.4 路由协议

路由协议的作用是让路由器**自动学习**到达到各个网络的最佳路径。

*   **内部网关协议**：在一个自治系统内部使用，如 **RIP**、**OSPF**。
    *   **RIP**：基于跳数，简单但规模有限，适用于小型网络。
    *   **OSPF**：基于链路状态（带宽、延迟等），复杂但高效，适用于大型网络。
*   **外部网关协议**：在不同自治系统之间使用，如 **BGP**。BGP是互联网的“骨架协议”，负责在不同运营商、大洲之间传递路由信息。

## 七、 Web 架构与进阶技术

### 7.1 CDN (内容分发网络)

**是什么**：CDN是部署在网络各地的边缘服务器集群，相当于一个离你更近的“缓存站点”。

**工作原理**：
1.  当你请求一个资源（如图片、视频）时，DNS会将你引导到** geographically closest**的CDN节点。
2.  如果该节点有缓存，直接返回（**缓存命中**）。
3.  如果没有，CDN节点会回**源站**拉取资源，缓存下来再返回给用户（**缓存回源**）。

**好处**：
*   **加速访问**：用户从附近的CDN节点获取数据，延迟更低。
*   **减轻源站负载**：大部分请求被CDN消化。
*   **高可用性**：即使源站宕机，部分缓存的资源仍可访问。

### 7.2 WebSocket

**为什么需要它**：HTTP是“一问一答”，服务器不能主动推数据给客户端。对于需要实时交互的应用（如聊天室、在线游戏、股票行情），使用HTTP轮询效率极低。

**WebSocket**：在单个TCP连接上提供**全双工**通信的协议。

**握手过程**：
1.  客户端首先发送一个特殊的HTTP请求（包含 `Upgrade: websocket` 头），请求“升级”协议。
2.  服务端同意升级，返回 `101 Switching Protocols` 状态码。
3.  此后，双方就可以在建立的TCP连接上，通过WebSocket数据帧进行自由的、双向的数据传输，不再受HTTP请求-应答模型的限制。

### 7.3 RESTful API

REST（Representational State Transfer）是一种软件架构风格，不是标准也不是协议。

**核心原则**：
1.  **资源**：网络上的所有事物都被抽象为资源（如用户、订单）。
2.  **URI**：使用统一的资源标识符来定位资源（如 `/users/123`）。
3.  **HTTP方法**：使用标准的HTTP方法对资源进行操作：
    *   `GET`：获取资源
    *   `POST`：创建资源
    *   `PUT`：更新整个资源
    *   `PATCH`：部分更新资源
    *   `DELETE`：删除资源
4.  **无状态**：服务器不保存客户端状态，每次请求都必须包含所有必要信息。

**设计良好的RESTful API特点**：清晰、可读、易于使用和维护。

### 7.4 RPC (远程过程调用) vs HTTP API

| 方面 | **RPC** | **HTTP API (如RESTful)** |
| :--- | :--- | :--- |
| **核心思想** | **调用远程方法**，像调用本地函数一样。 | **操作远程资源**，通过标准的HTTP方法。 |
| **协议** | 可以是自定义的二进制协议（如gRPC），也可以是基于HTTP的（如JSON-RPC）。 | 基于HTTP协议。 |
| **性能** | 通常更高，特别是使用二进制序列化（如Protobuf）时。 | 相对较低，JSON序列化/反序列化有开销。 |
| **耦合性** | **高**，客户端和服务端需要共享接口定义（IDL）。 | **低**，只依赖HTTP标准，更松散。 |
| **适用场景** | 内部微服务之间高性能通信。 | 对外的、需要广泛兼容的开放API。 |

**gRPC**：一个高性能、开源、通用的RPC框架，基于HTTP/2和Protocol Buffers。

## 八、 网络安全深度探讨

### 8.1 中间人攻击

**是什么**：攻击者秘密地在通信双方之间 relay 信息，使双方认为他们在直接对话，但实际上整个对话都被攻击者控制。

**HTTPS如何防范**：
1.  **加密**：通信内容被加密，即使被截获也无法解密。
2.  **身份验证**：通过数字证书验证服务器身份。浏览器会检查证书是否由可信CA签发、域名是否匹配、是否在有效期内。如果证书有问题，会向用户发出严重警告。

### 8.2 SQL注入进阶

**盲注**：一种SQL注入技巧，当页面没有直接回显数据库错误信息时，通过观察页面返回的“真”、“假”状态（如“存在此用户”或“不存在”）来一步步猜解数据库内容。

**防范的黄金法则**：
*   **永远不要信任用户输入**。
*   **使用预编译语句（Prepared Statements）**：这是最有效、最根本的解决办法。它将SQL代码和用户输入的数据分开发送，数据库会严格区分指令和数据，从而从根本上杜绝了注入的可能。
*   **使用ORM框架**：如MyBatis, Hibernate，它们通常内置了防注入机制。
*   **最小权限原则**：数据库连接账户不应拥有过高的权限（如DROP TABLE权限）。

### 8.3 点击劫持

**是什么**：攻击者将一个透明的、恶意的iframe覆盖在一个看似无害的按钮上，诱使用户点击，从而在用户不知情的情况下执行某个操作（如关注微博、转账）。

**防范**：
服务端通过设置HTTP响应头 `X-Frame-Options: SAMEORIGIN` 或 `DENY`，来禁止页面被嵌入到iframe中。

## 九、 性能优化与运维

### 9.1 TCP 优化内核参数

在Linux服务器上，可以通过调整内核参数来优化TCP性能。

*   `net.ipv4.tcp_tw_reuse`：允许重用处于TIME-WAIT状态的socket用于新的TCP连接。
*   `net.ipv4.tcp_syncookies`：防范SYN Flood攻击。
*   `net.core.somaxconn`：增大全连接队列的最大长度。
*   `net.ipv4.tcp_max_syn_backlog`：增大半连接队列的最大长度。

### 9.2 连接池

**为什么需要**：对于数据库、Redis等后端服务，每次请求都建立新的TCP连接开销巨大（三次握手、慢启动等）。

**连接池**：在应用启动时就创建好一定数量的数据库连接，并维护在一个“池子”里。当应用需要时，直接从池中取用一个空闲连接，用完后归还，而不是关闭它。

**好处**：极大地减少了建立和关闭连接的开销，提升了应用性能。

### 9.3 负载均衡算法进阶

除了轮询、IP哈希等，还有更智能的算法：

*   **最小连接数**：将新请求分配给当前连接数最少的服务器。适用于处理能力相近但连接持续时间不同的场景。
*   **加权最小连接数**：在最小连接数的基础上，考虑了服务器的处理能力权重。
*   **最少响应时间**：将请求分配给平均响应时间最短的服务器。

## 十、 现代网络协议趋势

### 10.1 HTTP/3 与 QUIC

**HTTP/2的遗留问题**：虽然HTTP/2解决了应用层的队头阻塞，但其底层仍是TCP。**TCP的队头阻塞**依然存在：如果一个TCP包丢失，所有后续包都必须等待重传，即使它们是不同HTTP流的数据。

**QUIC协议**：
*   **基于UDP**：在用户态实现，避免了TCP的队头阻塞。
*   **内置加密**：TLS 1.3是其设计的一部分，连接建立更快（通常0-RTT或1-RTT）。
*   **连接迁移**：当你的网络从WiFi切换到4G时，IP地址变了，但QUIC连接ID不变，连接不会中断。

**HTTP/3**：是HTTP语义在QUIC协议上的映射。可以简单理解为 **HTTP/3 = HTTP/2 + QUIC**。

### 10.2 IPv6

**为什么需要**：IPv4地址已经耗尽。
**IPv6特点**：
*   **地址空间巨大**：128位地址，号称“可以为地球上的每一粒沙子分配一个IP地址”。
*   **简化报头**：格式固定，便于路由器快速处理。
*   **更好的安全性和移动性支持**。

## 十一、 Linux 网络命令与故障排查实战大全

### 11.1 基础连通性与配置诊断

#### **ip 命令 (替代老旧的 ifconfig)**
**作用**：全能网络配置工具，查看和管理接口、路由、ARP表等。
```bash
# 查看所有网络接口信息（最常用）
ip addr show
# 简写
ip a

# 查看特定接口（如eth0）
ip addr show dev eth0

# 启用/禁用网络接口
ip link set eth0 up
ip link set eth0 down

# 查看路由表
ip route show
# 简写
ip r

# 查看ARP/邻居表（查看同一局域网内其他主机的MAC地址）
ip neighbor show
```

#### **ping**
**作用**：测试网络连通性、测量延迟和丢包。
```bash
# 基本用法
ping www.baidu.com

# 指定次数
ping -c 5 www.baidu.com

# 指定时间间隔（秒）
ping -i 0.5 www.baidu.com

# 指定超时时间（秒）
ping -W 2 www.baidu.com

# 持续ping，用于监控网络稳定性
ping -f www.baidu.com

# 指定数据包大小（字节）
ping -s 1000 www.baidu.com
```

#### **traceroute / tracepath**
**作用**：追踪数据包到达目标经过的路径，定位网络瓶颈。
```bash
# 显示数据包经过的每一跳
traceroute www.google.com

# 不进行DNS反向解析，加快速度
traceroute -n www.google.com

# 指定最大跳数
traceroute -m 30 www.google.com

# tracepath是traceroute的简单替代
tracepath www.google.com
```

### 11.2 端口与服务诊断

#### **netstat (老牌工具)**
**作用**：显示网络连接、路由表、接口统计等信息。
```bash
# 查看所有监听端口
netstat -tulnp

# 查看所有TCP连接
netstat -tan

# 查看所有UDP连接
netstat -uan

# 统计各种连接状态的数量（非常有用！）
netstat -an | awk '/^tcp/ {++S[$NF]} END {for(a in S) print a, S[a]}'
```

#### **ss (netstat的现代替代品，更快更详细)**
**作用**：获取socket统计信息，比netstat更高效。
```bash
# 查看所有监听端口（最常用）
ss -tulnp

# 查看所有已建立的TCP连接
ss -t -a

# 查看连接到特定端口的连接
ss -t -a sport = :80

# 查看进程使用的端口
ss -tulnp | grep nginx

# 显示计时器信息（了解连接状态）
ss -t -o
```

#### **lsof**
**作用**：列出系统打开的文件，包括网络连接。
```bash
# 查看哪个进程在监听80端口
lsof -i :80

# 查看特定进程打开的所有网络连接
lsof -i -a -p <pid>

# 查看所有TCP连接
lsof -i tcp

# 查看所有UDP连接
lsof -i udp
```

### 11.3 网络性能与流量分析

#### **iftop**
**作用**：实时监控网络带宽使用情况，类似top命令。
```bash
# 监控所有接口的带宽
iftop

# 监控特定接口
iftop -i eth0

# 显示端口号
iftop -P

# 不进行DNS解析
iftop -n
```

#### **nload**
**作用**：简单的实时网络流量监控工具。
```bash
# 监控所有接口
nload

# 监控特定接口
nload eth0

# 以MB为单位显示
nload -u M
```

#### **ethtool**
**作用**：查询和控制网络驱动程序和硬件设置。
```bash
# 查看网卡基本信息
ethtool eth0

# 查看网卡驱动信息
ethtool -i eth0

# 查看网卡统计信息（错误包、丢包等）
ethtool -S eth0

# 查看和设置网卡速率
ethtool eth0 | grep Speed
ethtool -s eth0 speed 1000 duplex full

# 查看网卡连接状态
ethtool eth0 | grep "Link detected"
```

### 11.4 深度包检测与分析

#### **tcpdump**
**作用**：强大的命令行抓包工具。
```bash
# 抓取所有经过eth0的包
tcpdump -i eth0

# 抓取特定主机的流量
tcpdump -i any host 192.168.1.100

# 抓取特定端口的流量
tcpdump -i any port 80

# 抓取HTTP GET请求
tcpdump -i any -A -s 0 'tcp port 80 and tcp[((tcp[12:1] & 0xf0) >> 2):4] = 0x47455420'

# 将抓包结果保存到文件
tcpdump -i any -w capture.pcap port 80

# 从文件中读取并分析
tcpdump -r capture.pcap -n
```

#### **nc (netcat) - 网络瑞士军刀**
**作用**：多功能网络工具，用于调试TCP/UDP连接。
```bash
# 测试TCP端口连通性
nc -zv www.baidu.com 80

# 测试UDP端口
nc -zvu 8.8.8.8 53

# 作为临时服务器监听端口
nc -l 9999

# 作为客户端连接
nc localhost 9999

# 端口扫描（简单版）
nc -zv 192.168.1.1 20-30
```

### 11.5 DNS 诊断工具

#### **dig**
**作用**：专业的DNS查询工具。
```bash
# 查询A记录
dig www.baidu.com

# 查询特定记录类型
dig www.baidu.com AAAA
dig baidu.com MX
dig baidu.com NS

# 指定DNS服务器查询
dig @8.8.8.8 www.baidu.com

# 跟踪DNS解析全过程
dig +trace www.baidu.com

# 简洁输出
dig +short www.baidu.com
```

#### **nslookup**
**作用**：查询DNS记录，比dig简单。
```bash
# 交互模式
nslookup
> www.baidu.com
> server 8.8.8.8
> exit

# 直接查询
nslookup www.baidu.com
nslookup -type=MX baidu.com
```

#### **host**
**作用**：简单的DNS查询工具。
```bash
# 查询域名
host www.baidu.com

# 查询所有记录
host -a www.baidu.com

# 反向DNS查询
host 8.8.8.8
```

### 11.6 系统化故障排查流程

#### **场景1：网站无法访问**
```bash
# 1. 检查本地网络配置
ip a show dev eth0
ip route show

# 2. 测试基础连通性
ping -c 3 8.8.8.8
ping -c 3 www.baidu.com

# 3. 检查DNS解析
nslookup www.baidu.com
dig www.baidu.com

# 4. 检查目标端口是否开放
nc -zv www.baidu.com 80
telnet www.baidu.com 80

# 5. 追踪网络路径
traceroute -n www.baidu.com

# 6. 检查本地防火墙
iptables -L -n
```

#### **场景2：服务器端口不通**
```bash
# 1. 检查服务是否在运行
systemctl status nginx
ps aux | grep nginx

# 2. 检查端口是否监听
ss -tulnp | grep :80
netstat -tulnp | grep :80

# 3. 检查进程权限
lsof -i :80

# 4. 检查服务器防火墙
iptables -L -n
firewall-cmd --list-all

# 5. 从其他机器测试
nc -zv 服务器IP 80

# 6. 抓包分析
tcpdump -i any host 服务器IP and port 80
```

#### **场景3：网络性能问题**
```bash
# 1. 查看带宽使用
iftop -i eth0
nload eth0

# 2. 查看连接统计
ss -s
netstat -s

# 3. 查看网卡统计和错误
ethtool -S eth0
ip -s link show eth0

# 4. 检查TCP重传
netstat -s | grep retransmit
ss -t -o | grep retrans

# 5. 测量延迟和抖动
ping -c 100 -i 0.1 目标IP | grep "min/avg/max"
```

#### **场景4：DNS问题排查**
```bash
# 1. 检查本地DNS配置
cat /etc/resolv.conf

# 2. 测试DNS解析
dig www.baidu.com
dig @8.8.8.8 www.baidu.com

# 3. 检查DNS缓存（如果使用systemd-resolved）
systemd-resolve --status

# 4. 完整DNS解析追踪
dig +trace www.baidu.com

# 5. 检查特定记录类型
dig www.baidu.com A
dig www.baidu.com AAAA
```

### 11.7 高级网络统计信息

#### **查看系统网络统计**
```bash
# 查看所有接口统计
cat /proc/net/dev

# 查看TCP详细统计
cat /proc/net/snmp

# 查看网络连接状态分布
ss -s

# 查看内核路由缓存
ip route show cache
```

#### **实时监控工具**
```bash
# 使用watch持续监控
watch -n 1 'ss -tulnp | grep :80'
watch -n 1 'netstat -s | grep retrans'
watch -n 1 'cat /proc/net/dev'

# 使用dstat综合监控
dstat -nf
```

### 11.8 网络调优相关命令

#### **查看和调整内核参数**
```bash
# 查看所有网络相关参数
sysctl -a | grep net

# 查看TCP相关参数
sysctl -a | grep tcp

# 临时修改参数
sysctl -w net.ipv4.tcp_tw_reuse=1

# 永久修改（编辑文件）
echo 'net.ipv4.tcp_tw_reuse=1' >> /etc/sysctl.conf
sysctl -p
```

